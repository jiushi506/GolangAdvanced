golang 调度器模型  GPM      https://www.zhihu.com/question/20862617/answer/27964865


### 操作系统中的一些概念
1. 什么是POSIX标准
   POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准，这个标准的发布是为了获得源代码级别的软件可移植性。举个例子，一个在POSIX兼容的操作系统编写的程序，应该可以在任何其它的POSIX操作系统（即使是来自另一个厂商）上编译执行。

2. 操作系统进程/线程调度
   当多进程同时竞争CPU时，只要有超过两个的进程处于就绪态，那么单CPU必须选择下一个要运行的进程，完成选择工作的程序称为调度程序（也称CPU调度器），线程的调度与进程类似。

3. 内核线程和用户线程
   计算机中线程可以分为内核线程和用户线程。用户就是运行于操作系统之上应用的线程，而内核线程则是操作系统创建的线程，因为操作系统是为应用提供服务的，比如管理软硬件资源、响应用户进程的种种合理以及不合理的要求。因此可以理解为内核线程代理了用户线程要做的工作。

### golang 调度器相关
1. 什么是GPM模型
   GPM是Golang的调度模型，作为Golang 1.1版本中的一个新的特性被发布。这个调度器可以在开发不改变任何原先代码的情况下使得Golang并行程序获得一个巨大的性能提升。性能提升的原因在于GPM调度器为我们做了协程调度的工作，使得协程之间的协作和切换更加高效。GPM模型主要由G，P，M三个结构体组成，代码实现在GOROOT/src/runtime/runtime2.go文件里。这部分我会在第三小节进行详细介绍。

2. 为什么Golang需要调度器
   我们知道操作系统提供了线程的调度功能，那么为什么golang还需要在用户空间创建一个调度器呢？
   首先无论是进程还是线程，它们的切换都需要一些资源开销，这个机制在操作系统中程序能够有序的运行。而在Golang协程的场景下情况就变了。协程粒度相比进程和线程都更小，系统中起百万数量级别的协程再正常不过，可以想象如果协程同样使用操作系统的调度机制，那么要耗费多少资源。这些都增加了Golang使用goroutine所不需要的资源开销。在Golang调度器的调度机制中，当一个Goroutine在进行阻塞操作（比如系统调用）时，调度器会把当前线程中的其他Goroutine移交到其他线程中继续执行， 从而避免了整个程序的阻塞，大大提升应用性能。

   另一个问题是操作系统的调度策略在Golang编程模型中发挥的功能比较有限。因为Golang在进行垃圾的时候要求停止所有线程程，并且内存必须处于一致性状态，这涉及等待运行线程到达内存一致性的那个时间点，操作系统的调度是不能感知到这个时间点的。而Golang自己的调度器能够时刻知道内存状态，进行一次GC消耗的代价可以降低到最小。

3. 调度器的设计
   首先，用户线程和内核线程有以下几种关系。

4. 调度器的实现

